#+TITLE: The Emacs Package Developer's Handbook
#+OPTIONS: broken-links:t num:nil H:8
#+TAGS: Emacs
#+SETUPFILE: export/setup/theme-bigblow-local.setup

#+HTML: <a href=https://alphapapa.github.io/dont-tread-on-emacs/><img src="dont-tread-on-emacs-150.png" align="right"></a>

After developing some little Emacs packages for a year or so, I began to notice how I'd forget little things that I learned, and then I'd have to go hunting for that information again.  I also noticed how there are some issues for which there doesn't seem to be a "best practice" or "Standard Operating Procedure" to refer to.

So this is intended to be a place to collect and organize information related to Emacs package development.  Built with Emacs, by Emacs package developers, for Emacs package developers.

You can read this Org file directly on the [[https://github.com/alphapapa/emacs-package-dev-handbook][repository]] rendered by GitHub (which lacks support for some features of the document, such as links between sections), or you can read the [[https://alphapapa.github.io/emacs-package-dev-handbook/][HTML version]].

*Note:* The primary sections are listed at the top of the page in the horizontal bar.

* Contents                                                         :noexport:
:PROPERTIES:
:TOC:      this
:END:
  -  [[#emacs-lisp][Emacs Lisp]]
    -  [[#asynchronicity][Asynchronicity]]
    -  [[#binding][Binding]]
    -  [[#buffers][Buffers]]
    -  [[#checkers--linters][Checkers / linters]]
    -  [[#collections-lists-vectors-hash-tables-etc][Collections (lists, vectors, hash-tables, etc.)]]
    -  [[#data-structure][Data structure]]
    -  [[#date--time][Date / Time]]
    -  [[#destructuring][Destructuring]]
    -  [[#editing][Editing]]
    -  [[#functions][Functions]]
    -  [[#general][General]]
    -  [[#highlighting--font-locking][Highlighting / font-locking]]
    -  [[#multiprocessing-generators-threads][Multiprocessing (generators, threads)]]
    -  [[#packaging][Packaging]]
    -  [[#pattern-matching][Pattern matching]]
    -  [[#profiling--optimization][Profiling / Optimization]]
    -  [[#refactoring][Refactoring]]
    -  [[#regular-expressions][Regular expressions]]
    -  [[#strings][Strings]]
    -  [[#testing][Testing]]
    -  [[#version-control][Version control]]
    -  [[#xml--html][XML / HTML]]
  -  [[#blogs][Blogs]]
  -  [[#people][People]]
  -  [[#contributions][Contributions]]
  -  [[#tasks][Tasks]]
  -  [[#code][Code]]

* Emacs Lisp                                                          :elisp:
:PROPERTIES:
:TOC:      1
:END:

** Asynchronicity                                                    :async:

See [[id:94092c16-061c-45c9-9c66-77c5fdeceee8][Multiprocessing (generators, threads)]].

** Binding                                             :scope:binding:
:PROPERTIES:
:ID:       50f0cde2-34ca-4131-a688-b434ecde6819
:END:

Information related to variable scope and binding in elisp code (e.g. lexical vs. dynamic scope).

*** Articles                                                     :articles:

**** [[https://nullprogram.com/blog/2017/10/27/][Make Flet Great Again Â« null program]]      :macros:flet:letf:
:PROPERTIES:
:archive.is: http://archive.is/T8dHM
:END:

Chris Wellons explains how the old ~cl~ macro ~flet~ changes in its new ~cl-lib~ version, ~cl-flet~, and how to use ~cl-letf~ to achieve the old functionality.  It's a way to override functions in both lexical and dynamic scope, which is especially useful for unit testing.

*** Libraries                                                   :libraries:

**** [[id:e85e4252-ea03-4473-b52f-9393e7527fad][dash.el]]

**** [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/thunk.el][thunk]]                                                      :built_in:
:PROPERTIES:
:ID:       2f389382-af81-4f18-b6bc-ef33e39df1eb
:END:

#+BEGIN_QUOTE
Thunk provides functions and macros to delay the evaluation of forms.

Use =thunk-delay= to delay the evaluation of a form (requires lexical-binding), and =thunk-force= to evaluate it. The result of
the evaluation is cached, and only happens once.

Here is an example of a form which evaluation is delayed:

    =(setq delayed (thunk-delay (message "this message is delayed")))=

=delayed= is not evaluated until =thunk-force= is called, like the following:

   =(thunk-force delayed)=

This file also defines macros =thunk-let= and =thunk-let*= that are analogous to =let= and =let*= but provide lazy evaluation of bindings by using thunks implicitly (i.e. in the expansion).
#+END_QUOTE

*** Tools                                                           :tools:

**** [[id:7247be4d-4f66-43ff-bb70-1b4a7458611b][Lexical binding]]                            :built_in:lexical_binding:

** Buffers                                                         :buffers:

*** Best practices                                         :best_practices:

**** Inserting strings                                           :strings:

Inserting strings into buffers with ~insert~ is generally fast, but it can slow down in buffers with lots of markers or overlays.  In general, it can be faster to insert one large string (which may include newlines).  For example:

#+BEGIN_SRC elisp :exports both :cache yes
  (let ((strings (cl-loop for i from 1 to 1000
                          collect (number-to-string i))))
    (garbage-collect)
    (--sort (< (caddr it) (caddr other))
            (cl-loop for times in '(1 10 100)
                     append (a-list "(loop do (insert ..."
                                    (cons times
                                          (benchmark-run-compiled times
                                            (with-temp-buffer
                                              (cl-loop for string in strings
                                                       do (insert string)))))
                                    "(apply #'insert ..."
                                    (cons times
                                          (benchmark-run-compiled times
                                            (with-temp-buffer
                                              (apply #'insert strings))))
                                    "(insert (apply #'concat ..."
                                    (cons times
                                          (benchmark-run-compiled times
                                            (with-temp-buffer
                                              (insert (apply #'concat strings)))))))))
#+END_SRC

#+RESULTS[aa866ca87dbf71476c735ed51fca7373934bbf4f]:
| (insert (apply #'concat ... | 100 | 0.000142085 | 0 | 0.0 |
| (insert (apply #'concat ... |  10 | 0.000161172 | 0 | 0.0 |
| (insert (apply #'concat ... |   1 |  0.00018764 | 0 | 0.0 |
| (apply #'insert ...         |  10 | 0.000665472 | 0 | 0.0 |
| (apply #'insert ...         | 100 | 0.000678471 | 0 | 0.0 |
| (apply #'insert ...         |   1 | 0.000755329 | 0 | 0.0 |
| (loop do (insert ...        |  10 | 0.000817031 | 0 | 0.0 |
| (loop do (insert ...        | 100 | 0.000869779 | 0 | 0.0 |
| (loop do (insert ...        |   1 | 0.001490397 | 0 | 0.0 |

The fastest method here is to call ~insert~ once with the result of calling ~concat~ once, using ~apply~ to pass all of the strings.  With 100 iterations, it's about 6x faster than the next-fastest method, and even with 1 iteration, it's over 2x faster.
*** Libraries                                                   :libraries:
:PROPERTIES:
:ID:       523aa766-36a3-4827-a114-6babf72edc6b
:END:

**** [[https://github.com/phillord/m-buffer-el][m-buffer-el: List Oriented Buffer Operations]]
:PROPERTIES:
:ID:       6858c112-9756-43b4-a2e3-fa00a71e9367
:END:

**** [[https://github.com/alezost/bui.el][bui.el: Buffer interface library]]

#+BEGIN_QUOTE
BUI (Buffer User Interface) is an Emacs library that can be used to make user interfaces to display some kind of entries (like packages, buffers, functions, etc.).  The intention of BUI is to be a high-level library which is convenient to be used both by:

package makers, as there is no need to bother about implementing routine details and usual features (like buffer history, filtering displayed entries, etc.);

users, as it provides familiar and intuitive interfaces with usual keys (for moving by lines, marking, sorting, switching between buttons); and what is also important, the defined interfaces are highly configurable through various generated variables.
#+END_QUOTE

** Checkers / linters                                     :linters:checkers:

*** TODO Flycheck-package

** Collections (lists, vectors, hash-tables, etc.)             :collections:

*** Best practices                                         :best_practices:

**** Filtering a list

Using ~-select~ from =dash.el= seems to be the fastest way:

#+BEGIN_SRC elisp :exports both :cache yes
  (let ((list (cl-loop for i from 1 to 1000
                       collect i)))
    (bench-multi :times 100
      :ensure-equal t
      :forms (("(-non-nil (--map (when ..." (-non-nil
                                             (--map (when (cl-evenp it) it) list)))
              ("(delq nil (--map (when ..." (delq nil
                                                  (--map (when (cl-evenp it) it) list)))
              ("cl-loop" (cl-loop for i in list
                                  when (cl-evenp i)
                                  collect i))
              ("-select" (-select #'cl-evenp list))
              ("cl-remove-if-not" (cl-remove-if-not #'cl-evenp list))
              ("seq-filter" (seq-filter #'cl-evenp  list)))))
#+END_SRC

#+RESULTS[6b2e97c1ebead84a53fd771684cc3e155e7f6b1e]:
| Form                       | x faster than next | Total runtime | # of GCs | Total GC runtime |
|----------------------------+--------------------+---------------+----------+------------------|
| -select                    |               1.17 |    0.01540391 |        0 |              0.0 |
| cl-loop                    |               1.05 |    0.01808226 |        0 |              0.0 |
| seq-filter                 |               1.13 |    0.01891708 |        0 |              0.0 |
| (delq nil (--map (when ... |               1.15 |    0.02134727 |        0 |              0.0 |
| cl-remove-if-not           |               1.18 |    0.02459478 |        0 |              0.0 |
| (-non-nil (--map (when ... |            slowest |    0.02903999 |        0 |              0.0 |

*** Examples                                                     :examples:

**** Alists                                                       :alists:

***** Creation

#+BEGIN_SRC elisp
  ;;;; Built-in methods

  (list (cons 'one 1) (cons 'two 2))  ;; => ((one . 1) (two . 2))

  '((one . 1) (two . 2))  ;; => ((one . 1) (two . 2))

  (let ((numbers (list)))
    (map-put numbers 'one 1)
    (map-put numbers 'two 2))  ;; => ((two . 2) (one . 1))


  ;;;; Packages

  ;; `a-list' from a.el is the best way to make a new alist.

  (a-list 'one 1
          'two 2)  ;; => ((one . 1) (two . 2))
#+END_SRC

***** Adding to

****** Single elements

#+BEGIN_SRC elisp
  ;;;; Built-in methods

  ;; `map-put' is the best built-in way.  Requires Emacs 25.1+.

  (let ((numbers (list (cons 'one 1))))
    (map-put numbers 'two 2)
    numbers)  ; => ((two . 2) (one . 1))

  ;; More primitive methods

  ;; Not recommended, but not too complicated:
  (let ((numbers (list (cons 'one 1)))
        (more-numbers (a-list 'two 2
                              'three 3)))
    (append numbers more-numbers)) ;; => ((one . 1) (two . 2) (three . 3))

  ;; Don't do it this way, but it does demonstrate list/cons-cell
  ;; structure:
  (let ((numbers (list (cons 'one 1))))
    (cons (cons 'three 3)
          (cons (cons 'two 2)
                numbers)))  ;; => ((three . 3) (two . 2) (one . 1))
#+END_SRC

****** Multiple elements

#+BEGIN_SRC elisp
  ;;;; Built-in methods

  ;; `map-merge': if you're restricted to built-in packages, this works
  ;; well (requires Emacs 25.1+):
  (let ((numbers (list (cons 'one 1)))
        (more-numbers (a-list 'two 2
                              'three 3)))
    (map-merge 'list numbers more-numbers))  ;; => ((three . 3) (two . 2) (one . 1))


  ;; Without map.el, you could use `append':
  (let ((numbers (list (cons 'one 1)))
        (more-numbers (a-list 'two 2
                              'three 3)))
    (append numbers more-numbers)) ;; => ((one . 1) (two . 2) (three . 3))

  ;;;; Packages

  ;; `a-merge' from a.el is probably the best way:
  (let ((numbers (list (cons 'one 1)))
        (more-numbers (a-list 'two 2
                              'three 3)))
    (a-merge numbers more-numbers))  ;; => ((three . 3) (two . 2) (one . 1))
#+END_SRC

*** Libraries                                                   :libraries:

**** [[https://github.com/plexus/a.el][a.el: functions for dealing with association lists and hash tables. Inspired by Clojure.]] :alists:hash_tables:

**** [[https://github.com/troyp/asoc.el][asoc.el: alist library]]                                       :alists:

**** [[https://github.com/nicferrier/emacs-kv][emacs-kv: key/value collection-type functions, for alists, hash tables and plists]] :alists:hash_tables:plists:

**** [[https://github.com/Wilfred/ht.el][ht.el: The missing hash table library]]                   :hash_tables:
:PROPERTIES:
:ID:       22b35972-c32f-467a-92ee-f8a155920756
:END:

This library provides a consistent and comprehensive set of functions for working with hash tables: they're named consistently, take a natural and consistent argument order, and cover operations that the standard Emacs functions don't.

**** [[https://github.com/rolandwalker/list-utils][list-utils: List-manipulation utility functions]]               :lists:
:PROPERTIES:
:ID:       4b4cbe99-f048-4043-a946-97f9d1a4be52
:END:

Similar to =dash.el=, but with slightly different behavior that may be useful, and some unique features.  These functions are provided:

| =make-tconc=                       | =list-utils-depth=                |
| =tconc-p=                          | =list-utils-flat-length=          |
| =tconc-list=                       | =list-utils-flatten=              |
| =tconc=                            | =list-utils-alist-or-flat-length= |
| =list-utils-cons-cell-p=           | =list-utils-alist-flatten=        |
| =list-utils-cyclic-length=         | =list-utils-insert-before=        |
| =list-utils-improper-p=            | =list-utils-insert-after=         |
| =list-utils-make-proper-copy=      | =list-utils-insert-before-pos=    |
| =list-utils-make-proper-inplace=   | =list-utils-insert-after-pos=     |
| =list-utils-make-improper-copy=    | =list-utils-and=                  |
| =list-utils-make-improper-inplace= | =list-utils-not=                  |
| =list-utils-linear-p=              | =list-utils-xor=                  |
| =list-utils-linear-subseq=         | =list-utils-uniq=                 |
| =list-utils-cyclic-p=              | =list-utils-dupes=                |
| =list-utils-cyclic-subseq=         | =list-utils-singlets=             |
| =list-utils-make-linear-copy=      | =list-utils-partition-dupes=      |
| =list-utils-make-linear-inplace=   | =list-utils-plist-reverse=        |
| =list-utils-safe-length=           | =list-utils-plist-del=            |
| =list-utils-safe-equal=            |                                   |

*** Tools                                                           :tools:

**** [[id:f8f0755b-c23b-45ad-98da-780d4044676a][let-alist]]

**** [[id:a58f65dc-d4a4-4a40-a573-a66a28f3619c][=with-dict=, =with-plist-vals=]]

** Data structure                                           :data_structure:

*** Articles                                                     :articles:

**** [[http://nullprogram.com/blog/2018/02/14/][Options for Structured Data in Emacs Lisp Â« null program]]
:PROPERTIES:
:archive.is: http://archive.is/YxwP5
:END:

** Date / Time                                                 :dates:times:

*** Libraries                                                   :libraries:

**** [[https://github.com/emacs-php/emacs-datetime][emacs-datetime]]
:PROPERTIES:
:ID:       45613ae9-97a2-4807-b099-a6c051f1a2c4
:END:

The primary function provided is: ~(datetime-format SYM-OR-FMT &optional TIME &rest OPTION)~

#+BEGIN_EXAMPLE elisp
  (datetime-format "%Y-%m-%d")
  (datetime-format 'atom)
  (datetime-format 'atom "2112-09-03 00:00:00" :timezone "UTC")
#+END_EXAMPLE

There are several other symbols provided besides ~atom~, such as ~rfc-3339~, which formats dates according to that RFC.

** Destructuring                                             :destructuring:

See [[id:b699e1a1-e34c-4ce8-a5dd-41161d2a1cbf][Pattern matching]].

** Editing                                                         :editing:
:PROPERTIES:
:TOC:      ignore-children
:END:

*** Tools                                                           :tools:

**** [[https://github.com/Malabarba/aggressive-indent-mode][aggressive-indent-mode: minor mode that keeps your code always indented]] :formatting:indentation:parentheses:
:PROPERTIES:
:ID:       4dc7c607-a116-4c39-b063-fe34bd20cccf
:END:

**** [[https://emacs.cafe/emacs/package/2017/08/01/beginend.html][beginend.el]] :navigation:
:PROPERTIES:
:ID:       a32ed391-8ce6-46b7-9367-8117829ce2e7
:END:

This package, by Damien Cassou and Matus Goljer, helps navigation by redefining the ~M-<~ and ~M->~ keys do, depending on the major-mode.

**** [[https://github.com/magnars/expand-region.el][expand-region.el: Increase selected region by semantic units]] :selection:region:
:PROPERTIES:
:ID:       88b496f4-8230-474e-b2ee-d8e4e8ca30d0
:END:

**** [[https://github.com/emacs-helm/helm-navi][helm-navi: Navigate file sections and language keywords using Helm]] :navigation:

**** [[https://github.com/victorhge/iedit][iedit: Edit multiple regions simultaneously in a buffer or a region]] :refactoring:

=iedit= makes it easy to rename symbols within a function or in a whole buffer.  Simply activate ~iedit-mode~ with point on a symbol, and it will be highlighted in the chosen scope, and any changes you make to the symbol are made in each highlighted occurrence.  It's like a smart, purposeful version of ~multiple-cursors~.

The editor of this handbook uses ~iedit~ with these customizations:

+  ~ap/iedit-or-flyspell~ :: Globally bound to @@html:<kbd>@@C-;@@html:</kbd>@@.  In a ~prog-mode~-derived buffer, either corrects the last misspelled word with ~flyspell~ when point is in a comment or string, or activates ~iedit-mode~.  In non- ~prog-mode~-derived buffers, corrects with ~flyspell~.

#+BEGIN_SRC elisp
  (defun ap/iedit-or-flyspell ()
    "Call `iedit-mode' or correct misspelling with flyspell, depending..."
    (interactive)
    (if (or iedit-mode
            (and (derived-mode-p 'prog-mode)
                 (not (or (nth 4 (syntax-ppss))
                          (nth 3 (syntax-ppss))))))
        ;; prog-mode is active and point is in a comment, string, or
        ;; already in iedit-mode
        (call-interactively #'ap/iedit-mode)
      ;; Not prog-mode or not in comment or string
      (if (not (equal flyspell-previous-command this-command))
          ;; FIXME: This mostly works, but if there are two words on the
          ;; same line that are misspelled, it doesn't work quite right
          ;; when correcting the earlier word after correcting the later
          ;; one

          ;; First correction; autocorrect
          (call-interactively 'flyspell-auto-correct-previous-word)
        ;; First correction was not wanted; use popup to choose
        (progn
          (save-excursion
            (undo)) ; This doesn't move point, which I think may be the problem.
          (flyspell-region (line-beginning-position) (line-end-position))
          (call-interactively 'flyspell-correct-previous-word-generic)))))
#+END_SRC

+  ~ap/iedit-mode~ :: Calls ~iedit-mode~ with function-local scope by default, or global scope when called with a universal prefix.

#+BEGIN_SRC elisp
  (defun ap/iedit-mode (orig-fn)
    "Call `iedit-mode' with function-local scope by default, or global scope if called with a universal prefix."
    (interactive)
    (pcase current-prefix-arg
      ('nil (funcall orig-fn '(0)))
      ('(4) (funcall orig-fn))
      (_ (user-error "`ap/iedit-mode' called with prefix: %s" prefix))))

  ;; Override default `iedit-mode' function with advice.
  (advice-add #'iedit-mode :around #'ap/iedit-mode)
#+END_SRC

+  Helpful minibuffer message :: Confirms when an ~iedit~ session has started.

#+BEGIN_SRC elisp
  (advice-add 'iedit-mode :after (lambda (&optional ignore)
                                   (when iedit-mode
                                     (minibuffer-message "iedit session started. Press C-; to end."))))
#+END_SRC

**** [[https://github.com/abo-abo/lispy][lispy: short and sweet LISP editing]]    :elisp:navigation:parentheses:
:PROPERTIES:
:ID:       ca3809ba-5900-4dfd-84a1-1ceecc048296
:END:

**** [[https://github.com/IvanMalison/multi-line][multi-line: multi-line everything from function invocations and definitions to array and map literals in a wide variety of languages]] :formatting:

**** [[https://github.com/magnars/multiple-cursors.el][multiple-cursors.el: Multiple cursors]]             :selection:editing:
:PROPERTIES:
:ID:       deefcbc5-0c37-4936-a820-df99ae31a401
:END:

**** [[https://github.com/Fuco1/smartparens][smartparens: Minor mode  that deals with parens pairs and tries to be smart about it]] :navigation:editing:parentheses:
:PROPERTIES:
:ID:       e806d7f3-43e9-4260-aae4-479efbd41653
:END:

** Functions                                                     :functions:

Including anonymous functions (lambdas).

*** Articles

**** [[https://nullprogram.com/blog/2017/12/14/][What's in an Emacs Lambda Â« null program]] :lambdas:byte_compilation:lexical_binding:scope:
:PROPERTIES:
:archive.is: http://archive.is/ppIuJ
:ID:       54fa2e85-066f-431e-9db3-8b1627fac4ca
:END:

** General                                                         :general:

*** Libraries                                                   :libraries:

**** [[https://www.gnu.org/software/emacs/manual/html_node/cl/index.html][Common Lisp Extensions]] (=cl-lib=)                            :built_in:

This is the built-in =cl-lib= package which implements Common Lisp functions and control structures for Emacs Lisp.

**** [[https://github.com/magnars/dash.el][dash.el]]                                                        :dash:
:PROPERTIES:
:ID:       e85e4252-ea03-4473-b52f-9393e7527fad
:END:

Dash is a powerful general-purpose library that provides many useful functions and macros.

**** [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/subr-x.el][subr-x]]                                :built_in:strings:flow_control:

#+BEGIN_QUOTE
Less commonly used functions that complement basic APIs, often implemented in C code (like hash-tables and strings), and are not eligible for inclusion in subr.el.
#+END_QUOTE

This is a built-in package that provides several useful functions and macros, such as =thread-first= / =last=, =if-let= / =when-let=, hash-table functions, and string functions.  It's easy to forget about this, since:

#+BEGIN_QUOTE
Do not document these functions in the lispref.  http://lists.gnu.org/archive/html/emacs-devel/2014-01/msg01006.html
#+END_QUOTE

*** Tools                                                           :tools:

**** [[https://github.com/Lindydancer/el2markdown][el2markdown: Convert Emacs Lisp comments to MarkDown]]
:PROPERTIES:
:ID:       9aacf8f3-5244-4b71-8802-1c7876a9d19e
:END:

**** [[https://github.com/Lindydancer/multicolumn][multicolumn: Multiple side-by-side windows support]]
:PROPERTIES:
:ID:       267c8c25-53db-4ced-9242-176094e101e3
:END:

**** [[https://github.com/phillord/lentic][lentic: Create views of the same content in two buffers]]
:PROPERTIES:
:ID:       0c220bc9-7173-4b0f-8955-e10ab6db640f
:END:

**** [[https://github.com/Wilfred/suggest.el][suggest.el: discover elisp functions that do what you want]]
:PROPERTIES:
:ID:       57ecc064-7291-4cc5-a545-958e2bca295b
:END:

** Highlighting / font-locking                      :highlighting:font_lock:

*** Packages                                                     :packages:

Packages that do highlighting/font-locking.

**** [[https://github.com/Lindydancer/lisp-extra-font-lock][lisp-extra-font-lock: Highlight bound variables and quoted expressions in lisp]]
:PROPERTIES:
:ID:       5b4a9320-1d3d-441b-8505-7b35a8d323d3
:END:

*** Tools                                                           :tools:

Tools for developing highlighting/font-locking packages.

**** [[https://github.com/Lindydancer/face-explorer][face-explorer: Library and tools for faces and text properties]]
:PROPERTIES:
:ID:       66fef80f-0f92-4492-8199-01c24c635914
:END:

**** [[https://github.com/Lindydancer/faceup][faceup: Regression test system for font-lock keywords]]
:PROPERTIES:
:ID:       5ab6c330-15ae-455a-981c-bf298d9a2788
:END:

**** [[https://github.com/Lindydancer/font-lock-profiler][font-lock-profiler: Coverage and timing tool for font-lock keywords]]
:PROPERTIES:
:ID:       0f3ba4be-949b-4efe-8301-acf3873ab345
:END:

**** [[https://github.com/Lindydancer/font-lock-regression-suite][font-lock-regression-suite: Regression test suite for font-lock keywords of Emacs standard modes]]
:PROPERTIES:
:ID:       e54a2697-8b4a-4b65-a971-f79e0fa22120
:END:

**** [[https://github.com/Lindydancer/font-lock-studio][font-lock-studio: Debugger for Font Lock keywords]]
:PROPERTIES:
:ID:       fb9315d1-111d-4eab-8f99-00710e39b04c
:END:

**** [[https://github.com/Lindydancer/highlight-refontification][highlight-refontification: Visualize how font-lock refontifies a buffer]]
:PROPERTIES:
:ID:       85a2421d-6fbd-4c4d-a6f9-587258c8f625
:END:

** Multiprocessing (generators, threads)           :multiprocessing:
:PROPERTIES:
:ID:       94092c16-061c-45c9-9c66-77c5fdeceee8
:END:

*** Articles                                                     :articles:

**** [[https://nullprogram.com/blog/2018/05/31/][Emacs 26 Brings Generators and Threads Â« null program]] :threads:generators:byte_compilation:closures:iterators:
:PROPERTIES:
:archive.is: http://archive.is/Irane
:END:

Chris Wellons explains the new generators and threads that Emacs 26 provides.  He also shows an example of writing a ~cl-case~ form that uses the new ~switch~ jump table opcode in Emacs 26.

**** [[https://nullprogram.com/blog/2013/01/14/][Turning Asynchronous into Synchronous in Elisp Â« null program]] :async:
:PROPERTIES:
:archive.is: http://archive.is/AfL0y
:END:

**** [[https://nullprogram.com/blog/2017/02/14/][Asynchronous Requests from Emacs Dynamic Modules Â« null program]] :modules:async:
:PROPERTIES:
:archive.is: http://archive.is/ZS6pU
:END:

*** Manual                                                         :manual:

**** [[https://www.gnu.org/software/emacs/draft/manual/html_node/elisp/Generators.html][GNU Emacs Lisp Reference Manual: Generators]]              :generators:

**** [[https://www.gnu.org/software/emacs/draft/manual/html_node/elisp/Threads.html][GNU Emacs Lisp Reference Manual: Threads]]                    :threads:

** Packaging                                                     :packaging:
:PROPERTIES:
:TOC:      ignore-children
:END:

*** Best practices                                         :best_practices:

**** Autoloads                                                 :autoloads:

***** TODO Autoloading macro-generated functions

This may actually be a bug, or at least an unanswered question.

[[https://www.reddit.com/r/emacs/comments/63u5yn/how_to_use_autoload_cookies_for_custom_defunlike/][How to use autoload cookies for custom defun-like macros? : emacs]]:

#+BEGIN_QUOTE
Say I have a macro =deffoo= that expands to some custom kind of =defun=, and I want to use an autoload cookie to autoload the result. According to the manual,

#+BEGIN_EXAMPLE
    ;;;###autoload (deffoo bar   ...)
#+END_EXAMPLE

copies the entire form to =autoloads.el=, and something like

#+BEGIN_EXAMPLE
    ;;;###autoload (autoload 'bar "this-file") (deffoo bar   ...)
#+END_EXAMPLE

should be used instead. What confuses me is [[http://stackoverflow.com/a/38805102][this StackOverflow comment]] by who appears to be Stefan Monnier, saying that Emacs /should/ expand the macro before generating the autoload, and that it's probably a bug when this does not happen.

Can anyone clear up what the intended behaviour is?
#+END_QUOTE

[2018-01-15 Mon 03:37]  The correct way to do this is documented in [[https://github.com/alphapapa/helm-org-rifle/issues/13][this bug report]].

***** Articles                                                 :articles:

****** [[https://www.lunaryorn.com/posts/autoloads-in-emacs-lisp][Autoloads in Emacs Lisp | Sebastian Wiesner]]
:PROPERTIES:
:archive.is: http://archive.is/UZHhS
:END:

**** Integration with other packages

***** Optional support

Sometimes you want your package to integrate with other packages, but you don't want to require users to install those other packages.  For example, you might want your package to work with Helm, Ivy, or the built-in Emacs =completing-read=, but you don't want to declare a dependency on and =require= Helm or Ivy, which would force users to install them to use your package.

The best way to handle this is with the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Hooks-for-Loading.html][=with-eval-after-load=]] macro.  The [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Hooks-for-Loading.html][Emacs manual]] has a page on it, and [[https://stackoverflow.com/questions/21880139/what-is-with-eval-after-load-in-emacs-lisp][this StackOverflow question]] has some more info.  You can also see an [[https://github.com/alphapapa/org-recent-headings/blob/master/org-recent-headings.el#L350][example]], which also [[https://github.com/alphapapa/org-recent-headings/blob/master/org-recent-headings.el#L377][uses]] [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Declaring-Functions.html][=declare-function=]] to prevent byte-compiler errors.

**** [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lexical-Binding.html][Lexical binding]]                            :lexical_binding:built_in:
:PROPERTIES:
:ID:       7247be4d-4f66-43ff-bb70-1b4a7458611b
:END:

You should always use lexical binding by setting the header in the first line of the file:

#+BEGIN_EXAMPLE
  ;;; filename.el --- File description  -*- lexical-binding: t; -*-
#+END_EXAMPLE

***** Articles                                                 :articles:

****** [[https://yoo2080.wordpress.com/2013/09/11/emacs-lisp-lexical-binding-gotchas-and-related-best-practices/][Emacs Lisp lexical binding gotchas and related best practices | Yoo Box]]
:PROPERTIES:
:archive.is: http://archive.is/0nfB4
:END:

****** [[https://emacs.stackexchange.com/questions/2129/why-is-let-faster-with-lexical-scope][elisp - Why is `let' faster with lexical scope? - Emacs Stack Exchange]]
:PROPERTIES:
:archive.is: http://archive.is/LUtfZ
:END:

Sebastian Wiesner provides a detailed explanation.

****** [[https://www.emacswiki.org/emacs/DynamicBindingVsLexicalBinding][EmacsWiki: Dynamic Binding Vs Lexical Binding]]
:PROPERTIES:
:archive.is: http://archive.is/2VtOU
:END:

A lot of good examples and discussion.

**** Template
:PROPERTIES:
:ID:       aacd55b6-a56f-4064-bf0d-25173ce83ef3
:END:

When you make a new package, the =auto-insert= command will insert a set of standard package headers for you.  However, here is a more comprehensive template you can use:

#+BEGIN_SRC elisp
  ;;; package-name.el --- Package description (don't include the word "Emacs")  -*- lexical-binding: t; -*-

  ;; Copyright (C) 2017 First Last

  ;; Author: First Last <name@example.com>
  ;; URL: http://example.com/package-name.el
  ;; Version: 0.1-pre
  ;; Package-Requires: ((emacs "25.2"))
  ;; Keywords: something

  ;;; Commentary:

  ;; This is my package.  It is nice.  You should try it.

  ;;;; Installation

  ;;;;; MELPA

  ;; If you installed from MELPA, you're done.

  ;;;;; Manual

  ;; Install these required packages:

  ;; + foo
  ;; + bar

  ;; Then put this file in your load-path, and put this in your init
  ;; file:

  ;; (require 'package-name)

  ;;;; Usage

  ;; Run one of these commands:

  ;; `package-name-command': Frobnicate the flange.

  ;;;; Tips

  ;; + You can customize settings in the `package-name' group.

  ;;;; Credits

  ;; This package would not have been possible without the following
  ;; packages: foo[1], which showed me how to bifurcate, and bar[2],
  ;; which takes care of flanges.
  ;;
  ;;  [1] https://example.com/foo.el
  ;;  [2] https://example.com/bar.el

  ;;; License:

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

  ;;; Code:

  ;;;; Requirements

  (require 'foo)
  (require 'bar)

  ;;;; Customization

  (defgroup package-name nil
    "Settings for `package-name'."
    :link '(url-link "http://example.com/package-name.el"))

  (defcustom package-name-something nil
    "This setting does something."
    :type 'something)

  ;;;; Variables

  (defvar package-name-var nil
    "A variable.")

  ;;;;; Keymaps

  ;; This technique makes it easier and less verbose to define keymaps.

  (defvar package-name-map
    ;; This makes it easy and much less verbose to define keys
    (let ((map (make-sparse-keymap "package-name map"))
          (maps (list
                 ;; Mappings go here, e.g.:
                 "RET" #'package-name-RET-command
                 [remap search-forward] #'package-name-search-forward
                 )))
      (cl-loop for (key fn) on maps by #'cddr
               do (progn
                    (when (stringp key)
                      (setq key (kbd key)))
                    (define-key map key fn)))
      map))

  ;;;; Functions

  ;;;;; Commands

  ;;;###autoload
  (defun package-name-command (args)
    "Frobnicate the flange."
    (interactive)
    (package-name--something)
    (bar))

  ;;;;; Support

  (defun package-name--something (args)
    "This function helps frobnicate the flange."
    (foo))

  ;;;; Footer

  (provide 'package-name)

  ;;; package-name.el ends here
#+END_SRC

**** Readme

You should always include a readme with your project.  Typically it will be include most of the commentary section.  Here's a template that goes with the package template above:

#+BEGIN_SRC org
  ,#+PROPERTY: LOGGING nil

  # Note: This readme works with the org-make-toc <https://github.com/alphapapa/org-make-toc> package, which automatically updates the table of contents.

  ,* package-name
  :PROPERTIES:
  :TOC:      ignore
  :END:

  [[https://melpa.org/#/package-name][file:https://melpa.org/packages/package-name-badge.svg]] [[https://stable.melpa.org/#/package-name][file:https://stable.melpa.org/packages/package-name-badge.svg]]

  This is my package.  It is nice.  You should try it.

  ,** Screenshots

  This screenshot shows how to frobnicate the fripulator:

  [[screenshot1.png]]

  ,* Contents                                                         :noexport:
  :PROPERTIES:
  :TOC:      this
  :END:
    -  [[#installation][Installation]]
    -  [[#usage][Usage]]
    -  [[#changelog][Changelog]]
    -  [[#credits][Credits]]
    -  [[#development][Development]]
    -  [[#license][License]]

  ,* Installation
  :PROPERTIES:
  :TOC:      0
  :END:

  ,** MELPA

  If you installed from MELPA, you're done.  Just run one of the commands below.

  ,** Manual

    Install these required packages:

    + =foo=
    + =bar=

    Then put this file in your load-path, and put this in your init file:

    ,#+BEGIN_SRC elisp
  (require 'package-name)
    ,#+END_SRC

  ,* Usage
  :PROPERTIES:
  :TOC:      0
  :END:

    Run one of these commands:

    + =package-name-command=: Frobnicate the flange.

  ,** Tips

  + You can customize settings in the =package-name= group.

  ,* Changelog
  :PROPERTIES:
  :TOC:      0
  :END:

  ,** 1.1.0

  ,*Additions*
  +  Add command =package-name-debarnacle= to de-barnacle the hull.

  ,*Changes*
  + Command =package-name-anchor= now takes an argument, =weigh= or =let-go=.

  ,*Internal*
  +  Rewrote input parsing.
  +  Factored out anchor-weighing.

  ,** 1.0.1

  ,*Fixes*
  +  Ensure anchor is secure before returning from =package-name-anchor=.

  ,** 1.0.0

  Initial release.

  ,* Credits

    This package would not have been possible without the following packages: [[https://example.com/foo.el][foo]] which showed me how to bifurcate, and [[https://example.com/bar.el][bar]], which takes care of flanges.

  ,* Development

  Bug reports, feature requests, suggestions â /oh my/!

  ,* License

  GPLv3

  # Local Variables:
  # eval: (require 'org-make-toc)
  # before-save-hook: org-make-toc
  # org-export-with-properties: ()
  # org-export-with-title: t
  # End:

#+END_SRC

*** Reference                                                   :reference:

**** Package headers and structure
:PROPERTIES:
:ID:       036e2a71-f392-4c9a-a524-c5354f291e2f
:END:

The [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Simple-Packages.html][Emacs manual]] gives this example (I've added the lexical-binding part).  Also see [[id:aacd55b6-a56f-4064-bf0d-25173ce83ef3][template]].

#+BEGIN_EXAMPLE
  ;;; superfrobnicator.el --- Frobnicate and bifurcate flanges  -*- lexical-binding: t; -*-

  ;; Copyright (C) 2011 Free Software Foundation, Inc.

  ;; Author: J. R. Hacker <jrh@example.com>
  ;; Version: 1.3
  ;; Package-Requires: ((flange "1.0"))
  ;; Keywords: multimedia, frobnicate
  ;; URL: http://example.com/jrhacker/superfrobnicate

  ...

  ;;; Commentary:

  ;; This package provides a minor mode to frobnicate and/or
  ;; bifurcate any flanges you desire. To activate it, just type
  ...

  ;;;###autoload
  (define-minor-mode superfrobnicator-mode
  ...
#+END_EXAMPLE

*** Tools                                                           :tools:

**** Package installation/management             :installation:management:

***** [[https://github.com/Malabarba/paradox][paradox: modernizing Emacs' Package Menu. With package ratings, usage statistics, customizability, and more.]]
:PROPERTIES:
:ID:       2c31eae6-eeba-433f-bc26-9465d5aa8537
:END:

***** [[https://github.com/dimitri/el-get][el-get: Manage the external elisp bits and pieces upon which you depend!]]

***** TODO [[https://github.com/raxod502/straight.el][straight.el: Next-generation, purely functional package manager for the Emacs hacker]] :needs_examples:
:LOGBOOK:
-  State "TODO"       from              [2018-07-29 Sun 13:11]
:END:

***** TODO [[https://github.com/jwiegley/use-package][use-package: A use-package declaration for simplifying your .emacs]] :needs_examples:
:PROPERTIES:
:ID:       540617fd-d4ff-47df-89da-6c48c8f27785
:END:
:LOGBOOK:
-  State "TODO"       from              [2018-07-29 Sun 13:11]
:END:

Developed by the current maintainer of Emacs, himself, John Wiegley.

** Pattern matching                         :destructuring:pattern_matching:
:PROPERTIES:
:TOC:      ignore-children
:ID:       b699e1a1-e34c-4ce8-a5dd-41161d2a1cbf
:END:

*** Articles                                                     :articles:

**** [[http://www.wilfred.me.uk/blog/2017/03/19/pattern-matching-in-emacs-lisp/][Pattern Matching in Emacs Lisp â Wilfred Hughes::Blog]] :pcase:shadchen:cl:dash:
:PROPERTIES:
:archive.is: http://archive.is/J4DqY
:END:

#+BEGIN_QUOTE
Pattern matching is invaluable in elisp. Lists are ubiquitous, and a small amount of pattern matching can often replace a ton of verbose list fiddling.

Since this is Lisp, we have lots of choices! In this post, we'll compare [[https://www.gnu.org/software/emacs/manual/cl.html][cl.el]], [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Pattern-matching-case-statement.html][pcase.el]], [[https://github.com/magnars/dash.el][dash.el]], and [[https://github.com/VincentToups/shadchen-el][shadchen]], so you can choose the best fit for your project. We'll look at the most common use cases, and end with some recommendations.

For the sake of this post, we'll consider both pattern matching and destructuring, as they're closely related concepts.
#+END_QUOTE

**** [[http://kitchingroup.cheme.cmu.edu/blog/2017/04/16/A-callable-plist-data-structure-for-Emacs/][A callable plist data structure for Emacs]]             :plists:macros:
:PROPERTIES:
:archive.is: http://archive.is/vmITX
:ID:       9391ab92-5d51-4786-a3c5-4822ec500500
:END:

John Kitchin demonstrates some [[id:a58f65dc-d4a4-4a40-a573-a66a28f3619c][macros]] that make it easy to access plist values.

*** Libraries                                                   :libraries:

**** [[https://github.com/magnars/dash.el][dash.el]] :dash:

Dash is a powerful library, and one of its features is powerful destructuring with its ~-let~ macro, and several others that work the same way.

**** [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Pattern-matching-case-statement.html][pcase]]                                                :built_in:pcase:

~pcase~ is built-in to Emacs.  Its syntax can be confusing, but it is very powerful.

***** Articles                                                 :articles:

****** [[https://www.emacswiki.org/emacs/PatternMatching][EmacsWiki: Pattern Matching]]                  :examples:EmacsWiki:

There are /lots/ of examples here.

****** [[http://newartisans.com/2016/01/pattern-matching-with-pcase/][Emacs: Pattern Matching with pcase - Lost in Technopolis]]
:PROPERTIES:
:archive.is: http://archive.is/FAzd8
:END:

****** Nic Ferrier, [[http://nic.ferrier.me.uk/blog/2013_03/refactoring-elisp-polymorphically][Using Polymorphism as a Lisp refactoring tool]]
:PROPERTIES:
:archive.is: http://archive.is/0Y3Md
:END:

***** Examples                                                 :examples:

****** TODO ~dash~

[2018-07-27 Fri 23:29]  Dash has new abilities, including ~-setq~, and destructuring plists with implied variable names (i.e. just the keys can be specified, reducing repetition).

****** =pcase-let=                                         :destructuring:
This example shows the use of =pcase-let*= to destructure and bind a nested alist:

#+BEGIN_SRC elisp
  (let ((alphabets (a-list 'English (a-list 'first "a"
                                            'second "b")
                           'Greek (a-list 'first "Î±"
                                          'second "Î²"))))
    (pcase-let* (((map English) alphabets)
                 ((map ('first letter) second) English))
      (list letter second)))  ;; => ("a" "b")
#+END_SRC

**** [[https://github.com/VincentToups/shadchen-el][shadchen-el]]                                             :shadchen:el:

A powerful, Racket-style pattern-matching library.

*** Tools                                                           :tools:

**** let-alist                               :alists:macros:destructuring:
:PROPERTIES:
:ID:       f8f0755b-c23b-45ad-98da-780d4044676a
:END:

#+BEGIN_QUOTE
let-alist is the best thing to happen to associative lists since the invention of the cons cell. This little macro lets you easily access the contents of an alist, concisely and efficiently, without having to specify them preemptively. It comes built-in with 25.1, and is also available on GNU Elpa for older Emacsen.
#+END_QUOTE

[[http://endlessparentheses.com/new-on-elpa-and-in-emacs-25-1-let-alist.html][Example]]:

#+BEGIN_SRC elisp
  (defun sx-question-list--print-info (question-data)
    "DOC"
    (let-alist question-data
      (list
       question-data
       (vector
        (int-to-string .score)
        (int-to-string .answer_count)
        .title " "
        .owner.display_name
        .last_activity_date sx-question-list-ago-string
        " " .tags))))
#+END_SRC

***** Articles                                                 :articles:

****** [[http://endlessparentheses.com/new-on-elpa-and-in-emacs-25-1-let-alist.html][New on Elpa and in Emacs 25.1: let-alist Â· Endless Parentheses]]
:PROPERTIES:
:archive.is: http://archive.is/2wNFm
:END:

Here Artur introduces the macro and gives examples.

**** =with-dict=, =with-plist-vals=              :macros:plists:
:PROPERTIES:
:ID:       a58f65dc-d4a4-4a40-a573-a66a28f3619c
:END:

Courtesy of [[id:9391ab92-5d51-4786-a3c5-4822ec500500][John Kitchin]]:[fn:1:Copyright by John Kitchin, licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.]

#+BEGIN_SRC elisp
  (defmacro with-dict (key-vals &rest body)
    "A context-manager for a plist where each key is a callable
  function that returns the value."
    (declare (indent 1))
    (let* ((g (if (symbolp key-vals)
                  (symbol-value key-vals)
                key-vals))
           (keys (-slice g 0 nil 2)))
      `(labels ,(loop for key in keys
                      collect
                      (list key '() `(plist-get ',g ,key)))
         ,@body)))

  ;; Used as:

  (with-dict (:a 1 :b 'some-symbol :c 3)
             (:b))

  (let ((d '(:key1 1 :key2 some-other-symbol :key3 3)))
    (with-dict d
               (format "We got %s" (:key2))))
#+END_SRC

And:

#+BEGIN_SRC elisp
  (defmacro with-plist-vals (plist &rest body)
    "Bind the values of a plist to variables with the name of the keys."
    (declare (indent 1))
    `(let ,(loop for key in (-slice plist 0 nil 2)
                 for val in (-slice plist 1 nil 2)
                 collect (list (intern
                                (substring (symbol-name key) 1))
                               val))
       ,@body))

  ;; Used like:

  (with-plist-vals (:a 4 :b 6)
                   (* 2 a))
#+END_SRC

** Profiling / Optimization                         :profiling:optimization:

*** Articles                                                     :articles:

**** [[https://nullprogram.com/blog/2017/01/30/][How to Write Fast(er) Emacs Lisp Â« null program]]

Chris Wellons explains five ways to write faster Emacs Lisp code.

**** [[id:54fa2e85-066f-431e-9db3-8b1627fac4ca][What's in an Emacs Lambda Â« null program]]

*** Macros                                                         :macros:

**** =bench=
:PROPERTIES:
:ID:       89f94efd-fd6b-4fca-9a75-60790d7cafeb
:END:

From Phil Lord's [[http://phillord.github.io/m-buffer-el/#sec-5-1-2][m-buffer-el]]:

#+BEGIN_SRC elisp
  (cl-defmacro bench (&optional (times 100000) &rest body)
    "Call `benchmark-run-compiled' on BODY with TIMES iterations, returning list suitable for Org source block evaluation."
    (declare (indent defun))
    `(list '("Total runtime" "# of GCs" "Total GC runtime")
           'hline
           (benchmark-run-compiled ,times
             (progn
               ,@body))))
#+END_SRC

Used like this:

#+BEGIN_SRC elisp
  (bench 1000000
    (cons 'time (current-time)))
#+END_SRC

When called from an Org source block, it gives output like this:

#+RESULTS:
| Total runtime | # of GCs |   Total GC runtime |
|---------------+----------+--------------------|
|   1.657838266 |        3 | 1.4723854609999876 |

**** ~bench-multi~

This macro makes comparing multiple forms easy:

#+BEGIN_SRC elisp
  (cl-defmacro bench-multi (&key (times 1) forms ensure-equal)
    "Run FORMS with `benchmark-run-compiled' for TIMES iterations, returning list suitable for Org source block evaluation.

  When ENSURE-EQUAL is non-nil, compare the results of FORMS and
  ensure they are `equal'.  If they aren't, raise an error, and if
  the results are sequences, show the difference between them using
  `seq-difference'.

  If the first element of a form is a string, the string is used as
  the form's description in the results; otherwise, forms are
  numbered from 0.

  Before `benchmark-run-compiled' is called for each form,
  `garbage-collect' is called."
    (declare (indent defun))
    (let ((results (gensym))
          (result-times (gensym))
          (header '(("Form" "x faster than next" "Total runtime" "# of GCs" "Total GC runtime")
                    hline))
          (descriptions (cl-loop for form in forms
                                 for i from 0
                                 collect (if (stringp (car form))
                                             (prog1 (car form)
                                               (setf (nth i forms) (cadr (nth i forms))))
                                           i))))
      `(let* ((,results (make-hash-table))
              (,result-times (sort (list ,@(cl-loop for form in forms
                                                    for i from 0
                                                    for description = (nth i descriptions)
                                                    collect `(progn
                                                               (garbage-collect)
                                                               (cons ,description
                                                                     (benchmark-run-compiled ,times
                                                                       ,(if ensure-equal
                                                                            `(puthash ,description ,form ,results)
                                                                          form))))))
                                   (lambda (a b)
                                     (< (second a) (second b))))))
         ,(when ensure-equal
            `(cl-loop with keys = (hash-table-keys ,results)
                      for i from 0 to (- (length keys) 2)
                      unless (equal (gethash (nth i keys) ,results)
                                    (gethash (nth (1+ i) keys) ,results))
                      do (if (sequencep (gethash (car (hash-table-keys ,results)) ,results))
                             (let* ((k1) (k2)
                                    ;; If the difference in one order is nil, try in other order.
                                    (difference (or (setq k1 (nth i keys)
                                                          k2 (nth (1+ i) keys)
                                                          difference (seq-difference (gethash k1 ,results)
                                                                                     (gethash k2 ,results)))
                                                    (setq k1 (nth (1+ i) keys)
                                                          k2 (nth i keys)
                                                          difference (seq-difference (gethash k1 ,results)
                                                                                     (gethash k2 ,results))))))
                               (user-error "Forms' results not equal: difference (%s - %s): %S"
                                           k1 k2 difference))
                           ;; Not a sequence
                           (user-error "Forms' results not equal: %s:%S  %s:%S"
                                       (nth i keys) (nth (1+ i) keys)
                                       (gethash (nth i keys) ,results)
                                       (gethash (nth (1+ i) keys) ,results)))))
         ;; Add factors to times and return table
         (append ',header
                 (cl-loop with length = (length ,result-times)
                          for i from 0 to (1- length)
                          for time = (second (nth i ,result-times))
                          for description = (car (nth i ,result-times))
                          for factor = (if (< i (1- length))
                                           (format "%.2f" (/ (second (nth (1+ i) ,result-times))
                                                             (second (nth i ,result-times))))
                                         "slowest")
                          collect (append (list description factor)
                                          (cdr (nth i ,result-times))))))))
#+END_SRC

Used like:

#+BEGIN_SRC elisp :exports both :cache yes
  (bench-multi
    :forms (("org-map-entries" (sort (org-map-entries (lambda ()
                                                        (nth 4 (org-heading-components)))
                                                      "/+MAYBE" 'agenda)
                                     #'string<))
            ("regexp" (sort (-flatten
                             (-non-nil
                              (mapcar (lambda (file)
                                        (let ((case-fold-search t))
                                          (with-current-buffer (find-buffer-visiting file)
                                            (org-with-wide-buffer
                                             (goto-char (point-min))
                                             (cl-loop with regexp = (format org-heading-keyword-regexp-format "MAYBE")
                                                      while (re-search-forward regexp nil t)
                                                      collect (nth 4 (org-heading-components)))))))
                                      (org-agenda-files))))
                            #'string<))))
#+END_SRC

#+RESULTS[3316dc4375a3b162e32790bb7e72d715d7f756fb]:
| Form            | x faster than next | Total runtime | # of GCs | Total GC runtime |
|-----------------+--------------------+---------------+----------+------------------|
| regexp          | 62.50              |   0.043138672 |        0 |              0.0 |
| org-map-entries | slowest            |    2.69609941 |        0 |              0.0 |

It can also help catch bugs by ensuring that each form returns the same results.  For example, the benchmark above contains a subtle bug: because ~case-fold-search~ in the =regexp= form is non-nil, the regexp is compared case-insensitively, so it matches Org headings which start with =Maybe= rather than only ones which start with =MAYBE=.  Using the ~:ensure-equal t~ argument to ~bench-multi~ compares the results and raises an error showing the difference between the two sequences the forms evaluate to:

#+BEGIN_SRC elisp :exports code
  (bench-multi
    :ensure-equal t
    :forms (("org-map-entries" (sort (org-map-entries (lambda ()
                                                        (nth 4 (org-heading-components)))
                                                      "/+MAYBE" 'agenda)
                                     #'string<))
            ("regexp" (sort (-flatten
                             (-non-nil
                              (mapcar (lambda (file)
                                        (let ((case-fold-search t))
                                          (with-current-buffer (find-buffer-visiting file)
                                            (org-with-wide-buffer
                                             (goto-char (point-min))
                                             (cl-loop with regexp = (format org-heading-keyword-regexp-format "MAYBE")
                                                      while (re-search-forward regexp nil t)
                                                      collect (nth 4 (org-heading-components)))))))
                                      (org-agenda-files))))
                            #'string<))))
#+END_SRC

: user-error: Formsâ results not equal: difference (regexp - org-map-entries): ("Maybe this is not the case?")

Fixing the error, by setting ~case-fold-search~ to ~nil~, not only makes the forms give the same result but, in this case, doubles the performance of the faster form:

#+BEGIN_SRC elisp :exports both :cache yes
  (bench-multi
    :ensure-equal t
    :forms (("org-map-entries" (sort (org-map-entries (lambda ()
                                                        (nth 4 (org-heading-components)))
                                                      "/+MAYBE" 'agenda)
                                     #'string<))
            ("regexp" (sort (-flatten
                             (-non-nil
                              (mapcar (lambda (file)
                                        (let ((case-fold-search nil))
                                          (with-current-buffer (find-buffer-visiting file)
                                            (org-with-wide-buffer
                                             (goto-char (point-min))
                                             (cl-loop with regexp = (format org-heading-keyword-regexp-format "MAYBE")
                                                      while (re-search-forward regexp nil t)
                                                      collect (nth 4 (org-heading-components)))))))
                                      (org-agenda-files))))
                            #'string<))))
#+END_SRC

#+RESULTS[13bda5a63b7b851ff3aac91c6487a9eb22ad0fb7]:
| Form            | x faster than next | Total runtime | # of GCs | Total GC runtime |
|-----------------+--------------------+---------------+----------+------------------|
| regexp          | 125.70             |   0.021080791 |        0 |              0.0 |
| org-map-entries | slowest            |   2.649818971 |        0 |              0.0 |

So this macro showed which code is faster and helped catch a subtle bug.

**** =elp-profile=
:PROPERTIES:
:ID:       fd3fdece-0342-441c-8540-5a5c463890a5
:END:

Call this macro from an Org source block and you'll get a results block showing which 20 functions were called the most times, how long they took to run, etc.  =prefixes= should be a list of symbols matching the prefixes of the functions you want to instrument.

#+BEGIN_SRC elisp
  (defmacro elp-profile (times prefixes &rest body)
    (declare (indent defun))
    `(let (output)
       (dolist (prefix ,prefixes)
         (elp-instrument-package (symbol-name prefix)))
       (dotimes (x ,times)
         ,@body)
       (elp-results)
       (elp-restore-all)
       (point-min)
       (forward-line 20)
       (delete-region (point) (point-max))
       (setq output (buffer-substring-no-properties (point-min) (point-max)))
       (kill-buffer)
       (delete-window)
       (let ((rows (s-lines output)))
         (append (list (list "Function" "Times called" "Total time" "Average time")
                       'hline)
                 (cl-loop for row in rows
                          collect (s-split (rx (1+ space)) row 'omit-nulls))))))

  ;; Use like this:
  (elp-profile 10 '(map search goto-char car append)
    (goto-char (point-min))
    (search-forward "something"))
#+END_SRC

This gives a table like:

#+RESULTS:
| Function       | Times called |   Total time | Average time |
|----------------+--------------+--------------+--------------|
| mapcar         |           30 | 0.0036004130 | 0.0001200137 |
| search-forward |           10 | 2.089...e-05 | 2.089...e-06 |
| goto-char      |           10 |    6.926e-06 |    6.926e-07 |
| car            |           13 | 3.956...e-06 | 3.043...e-07 |
| append         |            1 |     5.96e-07 |     5.96e-07 |
| mapatoms       |            1 |            0 |          0.0 |

** Refactoring                                                 :refactoring:

*** Tools                                                           :tools:

**** [[https://github.com/Wilfred/emacs-refactor][emacs-refactor: language-specific refactoring]]
:PROPERTIES:
:ID:       d329f03e-ed1e-4205-a232-6eee16717795
:END:

** Reading and writing files                                           :file:

From [[https://swsnr.de/blog/2016/11/15/read-and-write-files-in-emacs-lisp/][Read and Write Files in Emacs Lisp]] by Sebastian Wiesner.

It is common to use =find-file= and =write-file= to read/write to files.
However, they have /side effects/ as interactive commands:

- =write-file= sets major mode in current buffer, which runs major mode hook
  -- there can be anything in it.
- =find-file= could prompt users for risky file local variables.

*** Library: [[https://github.com/rejeep/f.el][f.el]] by [[https://github.com/rejeep][Johan Andersson]]

The package provides =f-read-text=, =f-write-text=, =f-read-bytes=, =f-write-bytes=
and more.

An example:

#+BEGIN_SRC emacs-lisp
(let* ((filename (locate-user-emacs-file "foo.txt"))
       (contents (f-read-text filename 'utf-8)))
  (f-write-text (upcase contents) 'utf-8 filename))
#+END_SRC

** Regular expressions                                 :regular_expressions:

*** Tools                                                           :tools:

**** [[https://github.com/immerrr/ample-regexps.el][ample-regexps.el: Compose and reuse regular expressions with ease]]

=ample-regexps= complements the built-in ~rx~ macro by flexibly defining regular expressions with reusable parts.  In the following example, the ~define-arx~ macro defines three things:

+  A macro ~assignment-rx~, which expands to a regular expression string at compile time
+  A function ~assignment-rx-to-string~, which can be used at runtime
+  A variable ~assignment-rx-constituents~, containing form definitions to use

#+BEGIN_SRC elisp
  (define-arx assignment-rx
    '((alpha_ (regexp "[[:alpha:]_]"))
      (alnum_ (regexp "[[:alnum:]_]"))
      (ws (* blank))
      (id (seq symbol-start (+ alpha_) (* alnum_) symbol-end)))) ;; -> assignment-rx

  (assignment-rx id ws "=" ws id) ;; -> "\\_<[[:alpha:]_]+[[:alnum:]_]*\\_>[[:blank:]]*=[[:blank:]]*\\_<[[:alpha:]_]+[[:alnum:]_]*\\_>"
#+END_SRC

This example shows the use of a function to expand a list of strings into a sequence:

#+BEGIN_SRC elisp
  (define-arx cond-assignment-rx
    '((alpha_ (regexp "[[:alpha:]_]"))
      (alnum_ (regexp "[[:alnum:]_]"))
      (ws (* blank))
      (sym (:func (lambda (_form &rest args)
                    `(seq symbol-start (or ,@args) symbol-end))))
      (cond-keyword (sym "if" "elif" "while"))
      (id (sym (+ alpha_) (* alnum_))))) ;; -> cond-assignment-rx

  (cond-assignment-rx cond-keyword ws id ":" id ws "=" ws id) ;; -> "\\_<\\(?:elif\\|if\\|while\\)\\_>[[:blank:]]*\\_<\\(?:[[:alpha:]_]+\\|[[:alnum:]_]*\\)\\_>:\\_<\\(?:[[:alpha:]_]+\\|[[:alnum:]_]*\\)\\_>[[:blank:]]*=[[:blank:]]*\\_<\\(?:[[:alpha:]_]+\\|[[:alnum:]_]*\\)\\_>"
#+END_SRC

**** TODO [[https://github.com/joddie/pcre2el][pcre2el: Convert between PCRE, Emacs and rx regexp syntax]]

** Strings                                                         :strings:

*** Libraries                                                   :libraries:

**** [[https://github.com/magnars/s.el][s.el: The long lost Emacs string manipulation library]]

*** Tools                                                           :tools:

**** ~format$~ macro                                  :macros:interpolation:

The ~format$~ macro (currently hosted [[https://github.com/alphapapa/elexandria/blob/master/elexandria.el][here]]) allows for easy string interpolation, including optional ~%~ sequences as used by ~format~.  For example, this:

#+BEGIN_SRC elisp
  (format$ "Amount: ${amount% .02f} $name %s" date)
#+END_SRC

Expands to:

#+BEGIN_SRC elisp
  (format "Amount: % .02f %s %s" amount name date)
#+END_SRC

Since this happens at macro expansion time rather than at runtime, there is no performance penalty, in contrast to using ~s-lex-format~.

** Testing                                                         :testing:

*** Libraries                                                   :libraries:

**** [[https://github.com/phillord/assess][assess: Test support functions]]

*** Tools                                                    :tools:

**** [[https://github.com/jorgenschaefer/emacs-buttercup][buttercup: Behavior-Driven Emacs Lisp Testing]]
:PROPERTIES:
:ID:       108f5eb6-7307-4d4b-aaf1-dd2a8bb65a58
:END:

**** [[https://github.com/ecukes/ecukes][ecukes: Cucumber for Emacs]]
:PROPERTIES:
:ID:       f0cdf4dd-38ff-41a1-a4c1-8f7677940863
:END:

**** [[https://www.gnu.org/software/emacs/manual/html_node/ert/][Emacs Lisp Regression Testing]] (ERT)                        :built_in:
:PROPERTIES:
:ID:       386b23bd-5254-457f-9ba1-ca5cbf87fed3
:END:

This is the standard, built-in Emacs testing library, used by core code and third-party packages alike.

**** [[https://github.com/vermiculus/emake.el][emake.el: Test Elisp without the hoops]]

#+BEGIN_QUOTE
Test Elisp with services like Travis CI without the fuss of Cask â just you, your project, and (Emacs-)Make.

Things EMake does:

+ parses, installs, and runs tests for your package
+ provides all the power of Elisp to extend its capabilities on-demand

Things EMake will never do (or âreasons you may still need Caskâ):

+ manage your development environment or provide tools to do so
+ provide âbundler-likeâ exec abilities (this includes Caskâs emacs and eval commands)
#+END_QUOTE

** Version control                                         :version_control:

*** Packages                                                     :packages:

**** [[https://github.com/magit/magit][Magit]]                                                           :git:
:PROPERTIES:
:ID:       43daf455-caeb-4399-b1bb-15a10603018b
:END:

One of the "killer apps" for Emacs--and for git!

** XML / HTML                                                     :xml:html:

*** Libraries                                                   :libraries:

**** [[https://github.com/tali713/esxml][esxml: An elisp library for working with xml, esxml and sxml]]

Probably the most featureful, usable library at the moment.

#+BEGIN_QUOTE
This library provides to formats for xml code generation. The primary form is esxml. esxml is the form that is returned by such functions as libxml-parse-xml-region and is used internally by emacs in many xml related libraries.
#+END_QUOTE

It also provides =esxml-query=:

#+BEGIN_SRC elisp
  ;; Traditionally people pick one of the following options when faced
  ;; with the task of extracting data from XML in Emacs Lisp:
  ;;
  ;; - Using regular expressions on the unparsed document
  ;; - Manual tree traversal with `assoc', `car' and `cdr'
  ;;
  ;; Browsers faced a similar problem until jQuery happened, shortly
  ;; afterwards they started providing the `node.querySelector' and
  ;; `node.querySelectorAll' API for retrieving one or all nodes
  ;; matching a given CSS selector. This code implements the same API
  ;; with the `esxml-query' and `esxml-query-all' functions. The
  ;; following table summarizes the currently supported modifiers and
  ;; combinators:
  ;;
  ;; | Name                               | Supported? | Syntax      | 
  ;; |------------------------------------+------------+-------------|
  ;; | Namespaces                         | No         | foo|bar     | 
  ;; | Commas                             | Yes        | foo, bar    | 
  ;; | Descendant combinator              | Yes        | foo bar     | 
  ;; | Child combinator                   | Yes        | foo>bar     | 
  ;; | Adjacent sibling combinator        | No         | foo+bar     | 
  ;; | General sibling combinator         | No         | foo~bar     | 
  ;; | Universal selector                 | Yes        | *           | 
  ;; | Type selector                      | Yes        | tag         | 
  ;; | ID selector                        | Yes        | #foo        | 
  ;; | Class selector                     | Yes        | .foo        | 
  ;; | Attribute selector                 | Yes        | [foo]       | 
  ;; | Exact match attribute selector     | Yes        | [foo=bar]   | 
  ;; | Prefix match attribute selector    | Yes        | [foo^=bar]  | 
  ;; | Suffix match attribute selector    | Yes        | [foo$=bar]  | 
  ;; | Substring match attribute selector | Yes        | [foo*=bar]  | 
  ;; | Include match attribute selector   | Yes        | [foo~=bar]  | 
  ;; | Dash match attribute selector      | Yes        | [foo|=bar]  | 
  ;; | Attribute selector modifiers       | No         | [foo=bar i] | 
  ;; | Pseudo elements                    | No         | ::foo       | 
  ;; | Pseudo classes                     | No         | :foo        | 
#+END_SRC

Example:

#+BEGIN_SRC elisp
  (defun org-books--amazon (url)
    "Return plist of data for book at Amazon URL."
    (cl-flet ((field (target-field list)
                     (cl-loop for li in list
                              for (field value) = (ignore-errors
                                                    (-let (((_ _ (_ _ field) value) li))
                                                      (list field value)))
                              when (equal field target-field)
                              return (s-trim value))))
      (let* ((html (org-web-tools--get-url url))
             (tree (with-temp-buffer
                     (insert html)
                     (libxml-parse-html-region (point-min) (point-max))))
             (author (esxml-query "span.author a.contributorNameID *" tree))
             (title (esxml-query "div#booksTitle h1#title > span *" tree))
             (details (esxml-query-all "table#productDetailsTable ul li" tree))
             (date (if-let ((printed (third (esxml-query-all "div#booksTitle h1#title span *" tree))))
                       ;; Printed book
                       (s-replace "â " "" printed)
                     ;; Kindle book
                     (field "Publication Date:" details)))
             (asin (field "ASIN:" details))
             (publisher (-some->> (field "Publisher:" details)
                                  (replace-regexp-in-string (rx " (" (1+ anything) ")") "")))
             (isbn-10 (field "ISBN-10:" details))
             (isbn-13 (field "ISBN-13:" details)))
        (list :author author :title title :publisher publisher :date date
              :asin asin :isbn-10 isbn-10 :isbn-13 isbn-13))))
#+END_SRC

**** [[https://github.com/AdamNiederer/elquery][elquery: Read and manipulate HTML]]

#+BEGIN_QUOTE
Itâs like jQuery, but way less useful.
#+END_QUOTE

Example:

#+BEGIN_SRC html
  <html style="height: 100vh">
    <head class="kek"><title class="kek" data-bar="foo">Complex HTML Page</title></head>
    <body class="kek bur" style="height: 100%">
      <h1 id="bar" class="kek wow">Wow this is an example</h1>
      <input id="quux" class="kek foo"/>
      <iframe id="baz" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"
              width="100%" height="100%" src="example.org">
      </iframe>
    </body>
  </html>
#+END_SRC

#+BEGIN_SRC elisp
  (let ((html (elq-read-file "~/kek.html")))
    (elq-el (car (elq-$ ".kek#quux" html))) ; => "input"
    (mapcar 'elq-el (elq-$ ".kek" html)) ; => ("input" "h1" "body" "title" "head")
    (mapcar (lambda (el) (elq-el (elq-parent el)))
            (elq-$ ".kek" html)) ; => ("body" "body" "html" "head" "html")
    (mapcar (lambda (el) (mapcar 'elq-el (elq-siblings el)))
            (elq-$ ".kek" html)) ; => (("h1" "input" "iframe") ("h1" "input" "iframe") ("head" "body") ("title") ("head" "body"))
    (elq-$ ".kek" html) ; => Hope you didn't like your messages buffer
    (elq-write html nil)) ; => "<html style=\"height: 100vh\"> ... </html>"
#+END_SRC

**** [[https://github.com/skeeto/elfeed/blob/master/xml-query.el][elfeed/xml-query.el]]

Provides lisp-based (rather than string-based) selectors.  This library is primarily aimed at internal =elfeed= use rather than general use, however it may be useful to others.  The author is [[https://github.com/skeeto/elfeed/issues/189][considering]] publishing it separately.

#+BEGIN_SRC elisp
  ;; This query grabs the top-level paragraph content from XHTML.

  ;; (xml-query-all '(html body p *) xhtml)

  ;; This query extracts all the links from an Atom feed.

  ;; (xml-query-all '(feed entry link [rel "alternate"] :href) xml)
#+END_SRC

**** [[https://github.com/zweifisch/enlive][enlive: query html document with css selectors]]

This provides a limited set of lisp-based selectors (rather than string-based selectors).

Example:

#+BEGIN_SRC elisp
  (require 'enlive)

  (enlive-text
   (enlive-query (enlive-fetch "http://gnu.org/") [title])) ; => "The GNU Operating System and the Free Software Movement"
#+END_SRC

**** [[https://github.com/bddean/xml-plus][xml-plus: XML/HTML utilities]]

Mostly undocumented, providing three main functions:

#+BEGIN_SRC elisp
  ;; Utility functions for xml parse trees.
  ;; - `xml+-query-all' and `xml+-query-first' are query functions that search
  ;; descendants in node lists. They don't work with namespace-aware parsing yet
  ;;
  ;; - `xml+-node-text' gets node text
#+END_SRC
* Blogs                                                               :blogs:
:PROPERTIES:
:TOC:      0
:END:

** [[http://planet.emacsen.org/][Planet Emacsen]]

This is the main community aggregator.  You can find just about everyone's Emacs-related blog posts here.

** Sacha Chua's [[http://sachachua.com/blog/category/geek/emacs/emacs-news/][/Emacs News/]]

This is Sacha's weekly Emacs news digest.  Don't miss it!

** [[id:53c0b780-7d67-47a5-ad30-090526e2018f][Artur Malabarba's /Endless Parentheses/]]

** [[http://irreal.org/blog/][Irreal]]

One of the top Emacs blogs, frequently updated, and often highlights other interesting blog entries in the community.

** [[id:a8a8dd9f-4113-4d4c-9882-ac59a4e86c0e][Oleh Krehel]]'s [[https://oremacs.com][/(or emacs/]]
:PROPERTIES:
:ID:       b6e88f95-8c4f-4d18-a7df-de0820d76291
:END:
** [[id:12c7b803-9af2-4010-bca4-06304fbb69c7][Sacha Chua's /Living an Awesome Life/]]

* People                                                             :people:
:PROPERTIES:
:TOC: ignore-children
:END:

The Emacs community is so full of brilliant, generous people that I can't keep track of them all!  I will surely overlook many, and I will add them in no particular order, but merely as I come across them again and again.

** Anders Lindgren

Anders, aka Lindydancer, has written numerous packages to help with developing highlighting and font-lock packages, as well as some other useful tools.

+ [[https://github.com/Lindydancer][GitHub]]

*** Packages

**** [[id:9aacf8f3-5244-4b71-8802-1c7876a9d19e][el2markdown: Convert Emacs Lisp comments to MarkDown]]

**** [[id:66fef80f-0f92-4492-8199-01c24c635914][face-explorer: Library and tools for faces and text properties]]

**** [[id:5ab6c330-15ae-455a-981c-bf298d9a2788][faceup: Regression test system for font-lock keywords]]

**** [[id:0f3ba4be-949b-4efe-8301-acf3873ab345][font-lock-profiler: Coverage and timing tool for font-lock keywords]]

**** [[id:e54a2697-8b4a-4b65-a971-f79e0fa22120][font-lock-regression-suite: Regression test suite for font-lock keywords of Emacs standard modes]]

**** [[id:fb9315d1-111d-4eab-8f99-00710e39b04c][font-lock-studio: Debugger for Font Lock keywords]]

**** [[id:85a2421d-6fbd-4c4d-a6f9-587258c8f625][highlight-refontification: Visualize how font-lock refontifies a buffer]]

**** [[id:5b4a9320-1d3d-441b-8505-7b35a8d323d3][lisp-extra-font-lock: Highlight bound variables and quoted expressions in lisp]]

**** [[id:267c8c25-53db-4ced-9242-176094e101e3][multicolumn: Multiple side-by-side windows support]]

** Artur Malabarba
:PROPERTIES:
:ID:       53c0b780-7d67-47a5-ad30-090526e2018f
:END:

Another prolific Emacs contributor, package developer, and blogger.

+  [[http://endlessparentheses.com/new-on-elpa-and-in-emacs-25-1-let-alist.html][Blog: /Endless Parentheses/]]
+  [[https://github.com/Malabarba][GitHub]]


*** Packages
:PROPERTIES:
:ID:       ae5465ac-9fda-4c1a-9900-4fd1eeb173da
:END:

**** [[id:4dc7c607-a116-4c39-b063-fe34bd20cccf][aggressive-indent-mode]]

**** [[id:2c31eae6-eeba-433f-bc26-9465d5aa8537][paradox]]

** Damien Cassou

+  [[https://github.com/DamienCassou][GitHub]]

*** Packages

**** [[id:a32ed391-8ce6-46b7-9367-8117829ce2e7][beginend.el]]

** John Wiegley

John is the current Emacs maintainer.

+  [[http://newartisans.com/][Blog]]
+  [[https://github.com/jwiegley][GitHub]]

*** Packages

**** [[id:540617fd-d4ff-47df-89da-6c48c8f27785][use-package]]

** Jonas Bernoulli

Jonas is a prolific Emacs package developer and maintainer.  You could spend hours on his GitHub repo.

+ [[https://github.com/tarsius][GitHub]]

*** Packages

**** [[id:43daf455-caeb-4399-b1bb-15a10603018b][Magit]]

** Jorgen SchÃ¤fer

*** Packages                                                     :packages:

**** [[id:108f5eb6-7307-4d4b-aaf1-dd2a8bb65a58][buttercup: Behavior-Driven Emacs Lisp Testing]]

**** [[https://github.com/jorgenschaefer/circe][Circe, a Client for IRC in Emacs]]

**** [[https://github.com/jorgenschaefer/elpy][elpy: Emacs Python Development Environment]]

**** [[https://github.com/jorgenschaefer/pyvenv][pyvenv: Python virtual environment interface]]

** Magnar Sveen

+  [[https://github.com/magnars][GitHub]]


*** Packages

**** [[id:e85e4252-ea03-4473-b52f-9393e7527fad][dash.el]]

**** [[id:88b496f4-8230-474e-b2ee-d8e4e8ca30d0][expand-region.el]]

**** [[id:deefcbc5-0c37-4936-a820-df99ae31a401][multiple-cursors.el]]

**** [[*%5B%5Bhttps://github.com/magnars/s.el%5D%5Bs.el:%20The%20long%20lost%20Emacs%20string%20manipulation%20library%5D%5D][s.el]]

** Matus Goljer

+ [[https://github.com/Fuco1/][GitHub]]


*** Packages

**** [[*%5B%5Bhttps://github.com/magnars/dash.el%5D%5Bdash.el%5D%5D][dash.el]]
:PROPERTIES:
:ID:       827c9455-2747-4514-8d71-4558eff5a263
:END:

**** [[id:e806d7f3-43e9-4260-aae4-479efbd41653][smartparens]]

** Oleh Krehel
:PROPERTIES:
:ID:       a8a8dd9f-4113-4d4c-9882-ac59a4e86c0e
:END:

Oleh is a prolific package author, having contributed many very high-quality packages.  He also writes at [[id:b6e88f95-8c4f-4d18-a7df-de0820d76291][his blog]].

*** Packages                                                     :packages:

**** [[https://github.com/abo-abo/ace-window][ace-window: Quickly switch windows]]       :navigation:windows:buffers:

**** [[https://github.com/abo-abo/avy][avy: Jump to things tree-style]]                           :navigation:

**** [[https://github.com/abo-abo/hydra][hydra: make bindings that stick around]]                  :key_binding:

**** [[id:ca3809ba-5900-4dfd-84a1-1ceecc048296][lispy: short and sweet LISP editing]]

**** [[https://github.com/abo-abo/swiper][swiper: Ivy - a generic completion frontend, Swiper - isearch with an overview, and more. Oh, man!]] :navigation:

** Phil Lord

+ [[https://github.com/phillord][GitHub]]

*** Packages

**** [[id:0c220bc9-7173-4b0f-8955-e10ab6db640f][lentic: Create views of the same content in two buffers]]

**** [[id:6858c112-9756-43b4-a2e3-fa00a71e9367][m-buffer-el]]

** Roland Walker
:PROPERTIES:
:ID:       518289de-100e-4387-9917-2adaffc28f48
:END:

Roland has published a wide variety of useful Emacs packages.

+ [[https://github.com/rolandwalker?utf8=%25E2%259C%2593&tab=repositories&q=&type=source&language=emacs+lisp][GitHub]]

*** Packages

**** [[id:4b4cbe99-f048-4043-a946-97f9d1a4be52][list-utils: List-manipulation utility functions]]

** Sacha Chua
:PROPERTIES:
:ID:       12c7b803-9af2-4010-bca4-06304fbb69c7
:END:

Sacha could easily be nominated the official Emacs ambassador, were there to be one.  Her contributions to the Emacs and Org-mode communities are innumerable.  One of her greatest recent contributions is her weekly [[http://sachachua.com/blog/category/geek/emacs/emacs-news/][Emacs news]] posts that serve as a digest of everything that happened in the Emacs world over the past week.

+  [[http://sachachua.com/blog/][Blog: /Living an Awesome Life/]]
+  [[http://github.com/sachac/][GitHub]]

** Wilfred Hughes

Wilfred has published several useful packages, and he's also leading the [[https://github.com/Wilfred/remacs][Rust Emacs port]].

*** Packages

**** [[id:d329f03e-ed1e-4205-a232-6eee16717795][emacs-refactor]]

**** [[id:22b35972-c32f-467a-92ee-f8a155920756][ht.el]]

**** [[id:57ecc064-7291-4cc5-a545-958e2bca295b][suggest.el]]
:PROPERTIES:
:ID:       80aa6c33-72d6-4792-8f41-e8ac4f7a1b0d
:END:
* Contributions

Yes, please!  Please send pull requests and file issues on the [[https://github.com/alphapapa/emacs-package-dev-handbook][GitHub repo]].  This is intended to be a community project.

* Tasks
:PROPERTIES:
:TOC:      ignore-children
:END:

** TODO Articles to add [0/13]

*** TODO [[https://www.lunaryorn.com/posts/read-and-write-files-in-emacs-lisp][Read and write files in Emacs Lisp]] (5 min read)

*** TODO [[https://www.lunaryorn.com/posts/a-future-for-concurrency-in-emacs-lisp][A Future For Concurrency In Emacs Lisp]] (6 min read)

*** TODO [[https://www.lunaryorn.com/posts/a-blast-from-the-past-the-tale-of-concurrency-in-emacs][A Blast From The Past: The Tale Of Concurrency In Emacs]] (7 min read)

*** TODO [[https://www.lunaryorn.com/posts/I-wished-gnu-emacs-had][I wished GNU Emacs hadâ¦]] (2 min read)

*** TODO [[https://www.lunaryorn.com/posts/reproduce-bugs-in-emacs-Q][Reproduce bugs in emacs -Q]] (4 min read)

*** TODO [[https://www.lunaryorn.com/posts/use-package-el-really][Why package.el?]] (1 min read)

*** TODO [[https://www.lunaryorn.com/posts/my-emacs-configuration-with-use-package][My Emacs Configuration with use-package]] (8 min read)

*** TODO [[https://www.lunaryorn.com/posts/emacs-script-pitfalls][Emacs script pitfalls]] (13 min read)

*** TODO [[https://www.lunaryorn.com/posts/autoloads-in-emacs-lisp][Autoloads in Emacs Lisp]] (5 min read)

*** TODO [[https://www.lunaryorn.com/posts/advanced-syntactic-fontification][Advanced syntactic fontification]] (11 min read)

*** TODO [[https://www.lunaryorn.com/posts/calling-python-from-haskell][Calling Python from Haskell]] (12 min read)

*** TODO [[https://www.lunaryorn.com/posts/search-based-fontification-with-keywords][Search-based fontification with keywords]] (18 min read)

*** TODO [[https://www.lunaryorn.com/posts/syntactic-fontification-in-emacs][Syntactic fontification in Emacs]] (10 min read)

** TODO Add tips for new developers

e.g.:

-  Commonly used minor modes
     +  =highlight-funcalls=
     +  =highlight-quoted=
     +  =outline-minor-mode=

** TODO Add [[https://github.com/joddie/pcre2el]]
** TODO Add [[https://github.com/bbatsov/emacs-lisp-style-guide][GitHub - bbatsov/emacs-lisp-style-guide: A community-driven Emacs Lisp style guide]]

** TODO Add [[http://nic.ferrier.me.uk/][Nic Ferrier]]

*** TODO [[https://github.com/nicferrier/emacs-noflet][GitHub - nicferrier/emacs-noflet: noflet - nic's overriding flet, for fleting functions for the purpose of decorating them]]

** TODO Add [[https://github.com/vermiculus][Sean Allred]]

** TODO Add [[http://nullprogram.com/][Chris Wellons]]

+  http://github.com/skeeto
+  Elfeed
+  Other Emacs packages

** TODO Add [[https://github.com/wasamasa?][Vasilij Schneidermann]]

** TODO [[https://github.com/VincentToups/emacs-utils][Vincent Toups' projects]]

He has a lot of interesting libraries on his repo, and some of them are /extensively/ documented.  An aspiring Emacs Lisp developer could learn a lot from his code.

** TODO Add more of [[id:518289de-100e-4387-9917-2adaffc28f48][Roland Walker]]'s packages
** TODO Add MELPA

Mention @milkypostman, @purcell, @syohex, etc. Mention sandbox.

** TODO Add [[https://github.com/vermiculus/apiwrap.el][GitHub - vermiculus/apiwrap.el: Generate wrappers for your API endpoints!]]

** TODO Add [[http://www.modernemacs.com/][Modern Emacs]] site

** TODO Add [[https://github.com/sigma/pcache][GitHub - sigma/pcache: persistent caching for Emacs]]
** Testing

*** TODO Everything at [[https://www.emacswiki.org/emacs/UnitTesting][EmacsWiki: Unit Testing]]

*** TODO [[https://github.com/rejeep/el-mock.el][GitHub - rejeep/el-mock.el: Mocking library for Emacs]]

*** TODO [[https://github.com/sigma/mocker.el][GitHub - sigma/mocker.el: a simple mocking framework for Emacs]]

*** TODO [[https://www.emacswiki.org/emacs/EmacsLispExpectations][EmacsWiki: Emacs Lisp Expectations]]

** TODO Add databases section

*** TODO [[https://github.com/skeeto/emacsql][GitHub - skeeto/emacsql: A high-level Emacs Lisp RDBMS front-end]]

*** TODO [[https://github.com/pekingduck/emacs-sqlite3-api][GitHub - pekingduck/emacs-sqlite3-api: Native SQLite3 API for GNU Emacs]]
:PROPERTIES:
:ID:       caeb4340-1f2e-4c84-a604-80594b465a10
:END:

** TODO Tree-traversal

*** [[https://github.com/volrath/treepy.el][GitHub - volrath/treepy.el: Generic tree traversing tools for Emacs Lisp]]
:LOGBOOK:
-  State "TODO"       from              [2017-09-06 Wed 00:21]
:END:
** TODO Test in MELPA sandbox
:PROPERTIES:
:ID:       cddadde7-ec36-47a4-8d98-7acc39f03fed
:END:
:LOGBOOK:
-  State "TODO"       from              [2017-12-16 Sat 20:16]
:END:

[2017-07-29 Sat 00:33] Not only should you test installing and using your package in the sandbox, but you should /also/ test then exiting the sandbox Emacs, running it again with the package already installed, and loading it.  This is because, when the sandbox installs the package, the byte-compilation seems to load some things that won't be loaded the same way when only loading the byte-compiled file (especially if you have any ~eval-when-compile~ lines, or unusual macros or things that modify the environment when loaded).
* Code
:PROPERTIES:
:TOC:      0
:END:

This section contains code used to add to and update this document.

** UNDERWAY Automate adding new links and summaries
:LOGBOOK:
-  State "UNDERWAY"   from "TODO"       [2017-08-03 Thu 15:12]
:END:

*** TODO Get summary of page

*** DONE Get archive.is link for page
CLOSED: [2017-08-03 Thu 15:11]
:PROPERTIES:
:ID:       a0e9486f-24f0-47a6-8f21-50bcc7ac2ca0
:END:
:LOGBOOK:
-  State "DONE"       from "TODO"       [2017-08-03 Thu 15:11]
:END:

This bookmarklet should provide a way to get the URL:

#+BEGIN_SRC javascript
  javascript:void(open('https://archive.today/?run=1&url='+encodeURIComponent(document.location)))
#+END_SRC

Seems to only work if run in a browser, with JavaScript.  But there's a [[https://github.com/pastpages/archiveis][Python package]] that has a shell command.  So:

#+BEGIN_SRC elisp :results silent
  (require 's)

  (defun emacs-package-dev-handbook--archiveis-capture (url)
    "Return archive.is archived URL for URL."
    (with-temp-buffer
      (when (zerop (call-process "archiveis" nil t nil url))
        (s-trim (buffer-string)))))

  (cl-defun emacs-package-dev-handbook-insert-archiveis-property (&optional url)
    "Set the \"archive.is\" property for entry at point to the archived URL.
   Assumes heading on/before point is an Org link to a web page. If
   URL is given, archive that URL instead."
    (interactive)
    (when-let ((url (or url (save-excursion
                              (unless (org-at-heading-p)
                                (org-back-to-heading))
                              (beginning-of-line)
                              (when (re-search-forward org-bracket-link-regexp (line-end-position) 'noerror)
                                (org-link-unescape (match-string-no-properties 1))))))
               (archive-url (emacs-package-dev-handbook--archiveis-capture url)))
      (org-set-property "archive.is" archive-url)))
#+END_SRC

*** TODO Insert new entry at point

Maybe use capture templates and refile?

** Table of Contents

Currently using [[https://github.com/alphapapa/org-make-toc][org-make-toc]], which is uploaded but unfinished and unpackaged.

** Config

I love Emacs and Org mode.  This makes it so easy to make the document...alive!  And automated!  Beautiful.

# Local Variables:
# eval: (require 'org-make-toc)
# before-save-hook: org-make-toc
# after-save-hook: (lambda nil (when (org-html-export-to-html) (rename-file "README.html" "index.html" t)))
# org-export-with-properties: ()
# org-export-with-title: t
# End:
